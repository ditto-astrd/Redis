# 목차
1. 메시지 브로커의 역할과 개념
   (1) 메시징 큐
   (2) 이벤트 스트림
2. 레디스의 메시지 브로커

---
## 1. 메시지 브로커의 역할과 개념
- 메시지 브로커 : 예기치 못하게 서비스간 통신이 불가능한 상황이 발생하더라도 (ex : 갑작스러운 장애 및 다운타임) 보낸 메시지를 어딘가에 쌓아 둔 뒤 나중에 처리할 수 있는 채널을 만드는 것
  - 두가지 구조로 이루어짐 (1) 메시징 큐 (2) 이벤트 스트림

### (1) 메시지 큐
- 데이터를 생상하는 생산자(producer)와 수신하는 소비자(consumer)로 구성
- 생산자는 소비자의 큐로 데이터를 직접 푸시
  - ex) 2개의 서비스에 같은 메시지를 보내야 할 때 메시징 큐를 이용한다면 생산자는 2개의 각각 다른 메시징 큐에 각각 데이터를 푸시  
- 소비자가 데이터를 읽으면 큐에서 데이터를 삭제
  - 메시지를 보낸 다음 새로운 소비자가 추가되면, 소비자는 새롭게 추가된 이후의 이벤트만 확인 가능
  - 1:1 상황(= 한 서비스가 다른 서비스에게 동작을 지시)에서 유리
- 레디스의 `list` 자료구조의 push <-> pop으로 구현 가능
  - `list`에 데이터가 있는지 매번 확인할 필요 없이 대기하다가 새로운 데이터가 들어오면 읽어갈 수 있는 블로킹 기능을 사용
  - SNS의 타임라인(ex : 트위터의 타임라인)은 레디스의 list 자료구조로 관리
  - `list`의 블로킹을 통해 이벤트 루프의 비효율성을 줄임
    - 이벤트 루프를 돌며 신규로 처리할 이벤트가 있는지 체크하는 구조
    - 새로운 이벤트가 없으면 정해잔 시간 (polling inerval 폴링 인터벌) 동안 대기한 뒤, 이벤트에 큐에 데이터가 있는지 확인하는 과정 반복 (= polling 폴링)
    - 폴링 프로세스가 진행되는 동안 어플리케이션과 큐의 리소스가 불필요하게 소모될 수 있음
    - 또한 폴링 인터벌과 폴링 사이에 발생한 이벤트는 즉시 처리가 불가능하다는 단점 존재

### (2) 이벤트 스트림
- 데이터를 생성하는 발행자(publisher)와 조회하는 구독자(subscriber)로 지칭
- 스트림의 특정 저장소에 하나의 메시지를 보낼 수 있고, 메시지를 읽어가고자 하는 소비자들은 스트림에서 같은 메시지를 풀(pull)해 갈 수 있음 (메시지를 별도로 복제해서 저장하지 않아도 됨)
- 구독자가 읽어간 데이터는 바로 삭제되지 않고, 저장소의 설정에 따라 특정 기간 동안 저장될 수 있음
  - 따라서 중간에 신규 구독자가 생성되어도 데이터의 유효기간동안은 이전 데이터의 히스토리를 볼 수 있음
  - n:n 상황에서 유리
- 레디스의 `stream`을 사용하면 구현 가능
  - `kafka`에서 영감을 받았으며, 데이터는 계속해서 추가되는 방식으로 저장됨 (`append-only`)
  - 

## 2.레디스의 메시지 브로커
- 레디스의 pub <-> sub 구조로 구현 가능
  - 발행자가 특정 채널에 데이터를 전송하면 이 채널을 듣고 있는 모든 소비자는 데이터를 바로 소비할 수 있음
  - 레디스의 pub <-> sub 구조에서 모든 데이터는 한 번 채널 전체에 전파된 뒤 삭제되는 일회성을 가짐
  - 따라서 일회성의 특성상 메시지가 잘 전달됐는지는 보장하지 않음
  - 한번 전파된 데이터는 레디스에 저장되지 않으며, 단순히 메시지의 통로 역할만 제공
  - 만약 특정 구독자에 장애가 생겨 메시지를 받지 못했다 하더라도 그 사실을 알 수 없기 때문에 <mark>중요한 데이터를 전달하기에는 적합하지 않을 수 있음</mark>

### 메시지 publish 하기
``` redis
> PUBLISH hello world # hello를 구독하는 서버들에게 world라는 메시지 전달
(integer) 1           # 구독자 수를 반환
```

### 메시지 구독하기
``` redis
> SUBSCRIBE event1 event2    # 클라이언트는 event1과 event2를 동시 구독
Reading messages... (press Ctrl-C to quit)
1) "subscribe"
2) "event1"
3) (integer) 1
1) "subscribe"
2) "event2"
3) (integer) 2
```
- 클라이언트가 위의 커맨드를 수행하면 event1과 event2를 동시에 구독하며, 동시에 새로운 채널을 구독할 수는 있지만 pub/sub과 관련되지 않은 다른 커맨트는 수행할 수 없음

### 클러스터 구조에서 pub/sub
- 클러스터 구조에서도 pub / sub을 사용할 수 있으며, 메시지를 발행하면 해당 메시지는 클러스터에 속한 모든 노드에 자동으로 전달됨
  - 따라서 클로스터의 아무 노드에 연결해 SUBSCRIBE 커맨드를 사용하면 데이터를 수신할 수 있음
- 단, 클러스터 환경은 대규모 서비스에서 데이터를 분산해서 저장하고 처리하기 위해 도입됐으며, 이로 인해 <mark>불필요한 리소스 사용과 네트워크 부하가 발생할 수 있음</mark>

### sharded pub/sub
- 상기 언급된 비효율성을 해결하고자 레디스 7.0부터 도입됨
- 각 채널은 슬롯에 맵핑되며, 같은 슬롯을 가지고 있는 노드끼리만 pub / sub 메시지를 전파
  - 이로인해 메시지는 모든 노드로 전파되지 않기 때문에 불필요한 복제를 줄여 자원을 절약할 수 있음

