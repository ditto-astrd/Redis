# 목차
1. NoSQL이란?
2. Redis란?
3. Redis가 빠른 이유?
4. 싱글 스레드
5. 고가용성
6. 확장성
7. 메시지 브로커

---

### NoSQL이란?
- NoSQL
	- Not Only SQL
	- 관계형 DB에서 테이블의 데이터를 쿼리하기 위한 Standard Query Language를 사용하지 않는 데이터 저장소
- 장점
	- 실시간 응답
	- 확장성
		- 이벤트, 새해 첫날 트래픽, 세일 기간 등
	- 고가용성
	- 유연성
- 데이터 저장소 유형
	- 그래프 
		- 노드(node), 에지(edge), 속성(property)
	- 칼럼
		- 기존의 관계형 DB보다 유연한 스키마 관리 가능
		- Apache Casandra, HBase 등 빅데이터 처리에 적합
		- 대량의 데이터에 대한 집계 쿼리를 다른 유형보다 빠르게 처리할 수 있음
	- 문서
		- JSON과 같은 key - value 형태
		- 대표적으로 MongoDB, CouchDB
	- 키-값
		- 가장 단순하고 빠름
		- 게임, IoT, 로그를 남기는 작업 등 실시간 서비스에 적합
- 언제 NoSQL을 쓰면 좋나?
	- 그래프화된 데이터를 관계형 DB에 저장할 때
	- 실시간 로그 데이터와 같은 시계열 데이터는 실시간으로 저장해야하는 서비스이며, 이를 관계형 DB에 저장하면 쓰기 이슈가 발생할 수 있음
	- JSON 데이터를 관계형 DB에 저장하는 것도 쉽지 않음
		- 다양한 필드를 포함하기 때문
	- 관계형 DB를 사용하는 일부 기업에서는 테이블 구조 변경을 위해 데이터 아키텍트의 승인을 거쳐서 DBA가 작업을 진행하는 데이터 관리 체계로 인해 개발 속도가 저하될 수 있음
		- 반면 NoSQL을 쓰면 개발 팀이 바로 데이터 구조를 바꿀 수 있음

### Redis란?
- 고성능 키-값 인메모리 NoSQL
- 빠르고, 고 가용성, 확장성을 보장

### Redis가 빠른 이유?
- 인메모리 DB는 주 메모리(RAM)에 데이터를 저장하고 관리
	- 디스크에 의존하지 않고 메모리에만 데이터를 저장하므로 초고속 처리 가능
	- 모든 데이터가 컴퓨터의 메모리에서 관리되고, 디스크에 접근하는 과정이 필요 없기 때문에 처리 성능이 굉장히 빠름
- 온메모리 DB는 디스크에 데이터가 영구히 저장됨
	- 자주 사용되는 데이터는 캐싱돼 메모리에 올라와있는 경우도 있음
	- 그렇지 않은 경우, 데이터를 찾고자 할 때 직접 디스크에서 데이터를 검색 후 페이지 단위로 메모리에 올려 데이터를 찾는 과정이 반복됨
- 데이터의 영속성(데이터가 메모리를 넘어 디스크에 저장되는 정도)과 관련해서, 레디스는 데이터를 AOF(Append Only File)와 RDB(Redis Database) 형식으로 디스크에 주기적으로 저장할 수 있음
	- 레디스에 장애가 발생해 데이터가 유실되더라도 백업 파일을 이용하면 복구 가능

### 싱글 스레드
- Redis는 싱글 스레드로 동작
	- 메인 스레드 1개 + 별도 스래드 3개 = 총 4개
	- 이벤트 루프를 이용한 싱글 스레드로 동작
	- 따라서 최소 1개의 코어만 있어도 레디스를 사용할 수 있어 배포가 쉬움
		- CPU가 적은 서버에서도 좋은 성능을 낼 수 있음
- 한 사용자가 오래 걸리는 커멘드를 실행하면, 다른 사용자는 해당 쿼리가 완료될 때까지 대기해야 함
	- 인메모리 DB이니 웬만하면 빠른 응답을 갖지만, 간혹 반환이 느린 커맨드가 존재하니 이런 커멘드의 사용을 주의해야 함

### 고 가용성
- 자체적으로 HA(High Availability) 제공
- 복제를 통해 데이터를 여러 서버에 분산할 수 있으며, 센티널(Sentinel)은 장애 상황을 탐지해 자동으로 Fail Over를 실시
	- 어플리케이션이 센티널을 이용해 레디스에 연결하는 구조에서는 마스터에 장애가 발생하더라도 레디스로의 엔드포인트를 변경할 필요 없이 Fail Over가 완료돼 정상화 된 마스터 노드를 사용할 수 있음

### 확장성
- 레디스에서 클러스터 모드를 사용한다면 수평적 확장이 용이함
- 데이터는 레디스 클러스터 내에서 자동으로 샤딩된 후 저장되며, 어러 개의 복제본이 생성될 수 있음
- 이 데이터의 분리는 DB 레이어에서 처리되며 어플리케이션에서는 대상 데이터가 어떤 샤드에 있는지 신경쓰지 않아도 되므로, 레디스를 사용할 때와 동일하게 데이터를 가져오고 저장할 수 있음
- 클러스터 구조에서 모든 레디스 인스턴스는 클러스터 버스라는 프로토콜을 이용해 서로 감시하고 있으며, 이를 통해 클러스터의 마스터 노드에 문제가 발생하면 자동으로 Fail Over를 시켜 고가용성 유지 가능

### 메시지 브로커
- 단순히 NoSQL 데이터 저장소의 역할 뿐 아니라 메시징 기능도 가능
- 레디스의 pub / sub 기능은 가장 간단한 메시징 기능으로, 1개의 채널에 데이터를 던지면 이 채널을 듣고 있는 모든 소비자는 데이터를 빠르게 가져갈 수 있음
- pub / sub에서 모든 데이터는 전달된 뒤 삭제되는 일회성으로, 모든 메시징 상황에는 적합하지 않지만 fire - and - forget 패턴이 필요한 간단한 알림 서비스에서는 유용하게 사용 가능
- 레디스의 list 자료구조로 메시징 큐로 활용하기 적합
- 레디스의 stream 자료구조로 스트림 플랫폼을 사용할 수 있음
